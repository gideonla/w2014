\documentclass{article}
\usepackage{geometry}
\usepackage[namelimits,sumlimits]{amsmath}
\usepackage{amssymb,amsfonts}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage[cm]{fullpage}
\newcommand{\tab}{\hspace*{5em}}
\newcommand{\conj}{\overline}
\newcommand{\dd}{\partial}
\newcommand{\ep}{\epsilon}
\newcommand{\openm}{\begin{pmatrix}}
\newcommand{\closem}{\end{pmatrix}}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\Span}{span}
\DeclareMathOperator{\Null}{null}
\newcommand{\nc}{\newcommand}
\newcommand{\rn}{\mathbb{R}}
\newcommand{\zn}{\mathbb{Z}}
\nc{\cn}{\mathbb{C}}
\nc{\ssn}[1]{\subsubsection*{#1}}
\nc{\inner}[2]{\langle #1,#2\rangle}
\nc{\h}[1]{\widehat{#1}}
\nc{\tl}[1]{\widetilde{#1}}
\nc{\norm}[1]{\left\|{#1}\right\|}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\begin{document}
Name: Hall Liu

Date: \today 
\vspace{1.5cm}

\section*{Structure}
In addition to the provided modules which handle the packet generation/checksum calculation for us, we will define the \verb|queue| object, which will implement the lock-free queue described in class. The module will have 4 functions, \verb|create|, \verb|destroy|, \verb|enq|, and \verb|deq|. \verb|create| will initialize the associated memory/data structures and \verb|destroy| will free them. The other two do the sensible thing and add/remove objects from the queue. These will be located in \verb|queue.c| and \verb|queue.h|. Owing to the lack of generics in C, this queue will contain objects of the type \verb|void *|, which must then be cast to the appropriate type. 

The parallel version of the firewall will consist of two distinct parts -- the dispatcher and the workers. The dispatcher will be called as a function from \verb|main| with the necessary parameters (number of workers, number of packets, size of queue, packet distribution, and mean work).  The dispatcher function will then initialize required structures, spawn the $n-1$ worker threads, then loop and insert packets into the queue. Once the workers are finished, the dispatcher is responsible for deallocating the queues.

The worker threads will receive a pointer pointing to its queue object, and will loop repeatedly to pull packets from this queue and compute their fingerprint. The worker is responsible for deallocating the memory in the packets. 
\section*{Correctness testing}
\subsection*{Queue}
First, we need to verify the correctness of the queue object under one- and two-thread conditions. To test correctness under serial conditions, we should test what happens when we try to dequeue from an empty queue and enqueue to a full queue (the edge cases), as well as testing its order-preserving conditions. In other words, if we have one thread performing the enqueueing and the dequeueing, we want to satisify the invariant that if $a$ is enqueued before $b$, then if $a$ and $b$ are both dequeued at some point, then $a$ will be dequeued before $b$.

To test this invariant, we will generate random strings of enqueue/dequeue events with random integers in Python, then feed them into both the builtin Python implementation of a queue and the implementation to be tested. The integers will be cast to void pointers directly to store them into the queue (bad C, I know, but it can't hurt for these purposes). The outputs will be compared and verified for correctness.

In the parallel version, the invariants that we wish to verify are the following:
\begin{enumerate}
    \item If the enqueuing thread enqueues $n$ objects during some interval of time and the dequeuing thread is constantly trying to dequeue objects during said interval, then the dequeuing thread will succeed exactly $n$ times, and the successes will be returned in the same order as the enqueueing thread inserted them.
    \item If the enqueuing thread is constantly trying to enqueue objects in order from some infinite ordered set of objects and the dequeuing thread dequeues successfully $n$ times, then the $n$ objects returned are the first $n$ objects from the aforementioned infinite set.
\end{enumerate}
Unfortunately, we cannot implement this testing in Python due to the lack of proper multiprocessor support caused by the GIL. Thus, we will create two C functions that perform the requisite testing. The infinite ordered set of objects will naturally be the natural numbers, again encoded into void pointers. 
\end{document}
